
           Text FormatSec(Real sec, Text color, Text highlite) {
                if (sec > 10.) {
                    return highlite ^ TextLib::FormatReal(sec,3,False,False);
                }
                return color ^ 0 ^ highlite ^ TextLib::FormatReal(sec,3,False,False);
            }

            Text TimeToText(Integer intime) {
                declare Text highlite = "$eff";
                declare Text color = "$bcc";
                declare time = MathLib::Abs(intime);
                declare Integer cent = time % 1000;
                declare Integer sec2 = (time / 1000) % 60;
                declare Real sec = 1. * sec2 + cent * 0.001;
                declare Integer min = (time / 60000) % 60;
                declare Integer hour = time / 3600000;
                declare Text sign = "";
                if (intime < 0)  {
                    sign = "-";
                }

                if (hour > 0) {
                    return highlite ^ sign ^ hour ^ "'" ^ TextLib::FormatInteger(min,2) ^ ":" ^ FormatSec(sec, highlite,highlite);
                }

                if (min == 0) {
                    return color ^ sign ^ "00:" ^ FormatSec(sec, color, highlite);
                }

                if (min > 10)  {
                   return highlite ^ sign ^ min ^ ":" ^ FormatSec(sec, highlite, highlite);
                }

                return color ^ sign ^ 0 ^ highlite ^ min ^ ":" ^ FormatSec(sec, highlite, highlite);

            }


            Void UpdateCp(Integer _Index, Integer _Score, Boolean _Animate) {
                declare Integer ElementCount for Page = 20;
                if (_Index > ElementCount) {
                    return;
                }
                declare Integer[Integer] MapBestCheckpoints for Page = Integer[Integer];
                declare CMlLabel Label <=> (Page.GetFirstChild("Cp_"^ (_Index)) as CMlLabel);
                declare CMlQuad Bg <=> (Page.GetFirstChild("Bg_"^ (_Index)) as CMlQuad);
                declare CMlLabel HolderLabel <=> (Page.GetFirstChild("RecordHolder") as CMlLabel);
                declare Integer BestCp_Mode for LocalUser = 0;
                declare Text Color = "$fff";
                Bg.BgColor = TextLib::ToColor("000");

                declare Integer Compare = 99999999;

                switch (BestCp_Mode) {
                    case 0: {
                        if (Scores.existskey(0)) {
                            if (Scores[0].BestLap.Time > -1) {
                                HolderLabel.Value = Scores[0].User.Name;
                            } else {
                                HolderLabel.Value = "-";
                            }
                        }
                        if (MapBestCheckpoints.existskey(_Index)) {
                            Compare = MapBestCheckpoints[_Index];
                        } else {
                            Compare = 99999999;
                        }
                    }
                 /*
                 // disabled since no support from backend
                 case 1: {

                        HolderLabel.Value = localHolder;
                        if (localVariable.existskey(_Index)) {
                            Compare = localVariable[_Index];
                        } else {
                            Compare = 99999999;
                        }
                    }
                    case 2: {
                        HolderLabel.Value = dediHolder;
                        if (dediVariable.existskey(_Index)) {
                            Compare = dediVariable[_Index];
                        } else {
                            Compare = 99999999;
                        }
                    }
                    */
                }

                if (_Score == 99999999) {
                    if ( Compare > 0 && Compare != 99999999  ) {
                        Label.Value = "$fff$o" ^ (_Index) ^ " $o$bcc" ^ TimeToText(Compare);
                    } else {
                       Label.Value = "$fff$o" ^ (_Index) ^ " $o$bcc --:--.---";
                    }
                } else {
                    if (_Score < Compare) {
                       Bg.BgColor = TextLib::ToColor("00f");
                       Color = "$fff";
                    } else {
                       Bg.BgColor = TextLib::ToColor("f00");
                       Color = "$fff";
                    }
                    // Label.Value = "$fff$o" ^ (_Index+1) ^ " $o$bcc" ^ TimeToText(Compare) ^ "$fff" ^ " diff: " ^ Color ^ TimeToText(_Score - Compare);
                    Label.Value = "$fff$o" ^ (_Index) ^ " $o$bcc" ^ TimeToText(_Score - Compare);
                }
            }

            Void Refresh() {
                declare Integer ElementCount for Page = 19;
                declare Integer[Integer] MyCheckpoints for Page = Integer[Integer];
                declare Integer[Integer] MapBestCheckpoints for Page = Integer[Integer];
                declare Integer BestCp_Mode for LocalUser = 0;

                for (k, 0, (ElementCount-1)) {
                    if (MyCheckpoints.existskey(k)) {
                        UpdateCp(k, MyCheckpoints[k], False);
                    } else {
                        UpdateCp(k, 99999999, False);
                    }
                }

            }

             Void HideCp(Integer _Index) {
                (Page.GetFirstChild("Cp_"^ _Index) as CMlLabel).Hide();
                (Page.GetFirstChild("Bg_"^ _Index) as CMlFrame).Hide();
             }

            ***OnInit***
            ***
            declare localVariable = Integer[Integer];
            declare dediVariable = Integer[Integer];

            declare Integer ElementCount for Page = 19;
            declare Integer BestCp_Mode for LocalUser = 0;
          // declare CMlFrame Dropdown = (Page.GetFirstChild("uiDropdown") as CMlFrame);
            declare Integer[Integer] MyCheckpoints for Page = Integer[Integer];
            declare Integer[Integer] MapBestCheckpoints for Page = Integer[Integer];



            declare Integer[Integer] CompareCheckpoints for Page = Integer[Integer];
            declare Integer MapBestTime = 99999999;

            // clear
            for (i, 0, (ElementCount-1)) {
                MapBestCheckpoints[i] = 99999999;
            }

            // hide checkpoints not needed
            for (i, (MapCheckpointPos.count+1), (ElementCount)) {
                HideCp(i);
            }

            if (InputPlayer != Null) {
                foreach (k => i in InputPlayer.CurLap.Checkpoints) {
                            MyCheckpoints[k] = i;
                }
            }

            if (Scores.existskey(0)) {
                if (Scores[0].BestLap.Time > -1) {
                    MapBestTime = Scores[0].BestLap.Time;
                    foreach (k => i in Scores[0].BestLap.Checkpoints) {
                        MapBestCheckpoints[k] = i;
                    }
                }
            }

            Refresh();

        //    Dropdown.DataAttributeSet("selected", ""^BestCp_Mode);
        //    uiRenderDropdown(Dropdown);
            ***


            ***Loop***
            ***
            foreach (RaceEvent in RaceEvents) {
                if (GUIPlayer == RaceEvent.Player && RaceEvent.Type == CTmRaceClientEvent::EType::Respawn) {
                     if (GUIPlayer.RaceState == CTmMlPlayer::ERaceState::BeforeStart) {
                        MyCheckpoints = Integer[Integer];
                        Refresh();
                     }
                }

                if (RaceEvent.Type == CTmRaceClientEvent::EType::WayPoint) {

                    if (RaceEvent.IsEndRace || RaceEvent.IsEndLap) {

                        if (RaceEvent.LapTime < MapBestTime) {
                            MapBestTime = RaceEvent.LapTime;
                            if (GUIPlayer == RaceEvent.Player) {
                                MyCheckpoints[RaceEvent.CheckpointInLap] = RaceEvent.LapTime;
                                MapBestCheckpoints = MyCheckpoints;
                                MyCheckpoints = Integer[Integer];
                                Refresh();
                            } else {
                                foreach (k => i in RaceEvent.Player.Score.BestLap.Checkpoints) {
                                    MapBestCheckpoints[k] = i;
                                }
                                Refresh();
                            }


                        } else {
                            if (GUIPlayer == RaceEvent.Player && localVariable.count > 0 &&
                            MapBestTime != 99999999) {
                                if (RaceEvent.IsEndLap && RaceEvent.IsEndRace == False) {
                                    MyCheckpoints = Integer[Integer];
                                    Refresh();
                                } else {
                                    UpdateCp(RaceEvent.CheckpointInLap, RaceEvent.LapTime, True);
                                }
                            }
                        }
                    } else {
                        if (GUIPlayer == RaceEvent.Player && RaceEvent.CheckpointInLap < ElementCount) {
                            MyCheckpoints[RaceEvent.CheckpointInLap] = RaceEvent.LapTime;

                            switch (BestCp_Mode) {
                                case 0:  {
                                    if (MapBestTime != 99999999) {
                                        UpdateCp(RaceEvent.CheckpointInLap, RaceEvent.LapTime, True);
                                    }
                                }
                              /*  case 1: {
                                   if (localVariable.count > 0) {
                                        UpdateCp(RaceEvent.CheckpointInLap, RaceEvent.LapTime, True);
                                   }
                                }
                                case 2: {
                                   if (dediVariable.count > 0) {
                                        UpdateCp(RaceEvent.CheckpointInLap, RaceEvent.LapTime, True);
                                   }
                                } 
                                */
                            }
                        }
                    }
                }
            }
            ***

